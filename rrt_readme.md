# Drone Simulation using Rapidly-exploring Random Trees (RRT) in PyBullet

This project simulates a drone using the Rapidly-exploring Random Trees (RRT) algorithm for path planning in a PyBullet physics environment. The drone navigates from a start location to a goal location while avoiding obstacles.

## Rapidly-exploring Random Trees (RRT) Algorithm Overview

RRT is a sampling-based path planning algorithm that efficiently searches non-convex, high-dimensional spaces by randomly building a space-filling tree. The tree is constructed incrementally from samples drawn randomly from the search space and is biased to grow towards unexplored portions of the space.

**Key Concepts of RRT:**

1.  **Tree Structure:** The RRT is a tree data structure where each node represents a configuration (position) in the search space, and edges represent feasible paths between configurations.

2.  **Sampling:** The algorithm starts with a root node (the start configuration) and iteratively adds new nodes to the tree. In each iteration, a random configuration is sampled from the search space.

3.  **Nearest Neighbor Search:** The node in the existing tree that is closest to the sampled configuration is identified.

4.  **Steering:** A new node is created by "steering" from the nearest node towards the sampled configuration. This typically involves moving a fixed distance (step size) in the direction of the sampled configuration.

5.  **Collision Checking:** The path between the nearest node and the new node is checked for collisions with obstacles. If the path is collision-free, the new node is added to the tree.

6.  **Goal Check:** If the new node is close enough to the goal, a path has been found.

7.  **Path Reconstruction:** The path from the root to the goal node is reconstructed by traversing the tree backwards from the goal node to the root using parent pointers.

**In the context of this drone simulation:**

*   **Configuration:** The 3D position of the drone.
*   **Start Configuration:** The initial position of the drone.
*   **Goal Configuration:** The desired position of the drone.
*   **Obstacles:** Objects in the environment that the drone must avoid.

## Code Structure

The code consists of the following main parts:

### Parameters

Defined at the top of the script, these parameters control the RRT algorithm and the simulation:

*   `NUM_DRONES`: The number of drones (typically 1 for RRT).
*   `NUM_ITERATIONS`: The maximum number of iterations for the RRT algorithm.
*   `DELTA`: The step size for expanding the tree (steering).
*   `GOAL_BIAS`: The probability of sampling the goal configuration directly.
*   `COLLISION_CHECK_STEP`: The resolution for collision checking along edges.
*   `DRONE_RADIUS`: The radius of the drone, used for collision detection.
*   `HOVER_HEIGHT`: The desired hovering height for the drone (for 2D path planning in a 3D environment).
*   `ARENA_SIZE`: The size of the square simulation area.
*   `GOAL_REACH_THRESHOLD`: The distance within which the drone is considered to have reached the goal.

### Environment Setup

*   Initializes the PyBullet physics engine (`p.connect(p.GUI)`).
*   Sets the gravity (`p.setGravity()`).
*   Loads a ground plane (`p.loadURDF("plane.urdf")`).
*   Defines the `start_pos` and `goal_pos`.
*   Visualizes the start (red) and goal (green) positions.
*   Creates obstacles using `create_obstacle()`.

### Node Class

*   `Node(pos)`: Represents a node in the RRT tree. Stores the position (`pos`) and a reference to the parent node (`parent`).

### Drone Class

*   `__init__(self, start_pos)`: Initializes the drone's position and loads the quadrotor URDF model.
*   `move_along_path(self)`: Moves the drone along the path generated by RRT.

### RRT Functions

*   `get_random_config()`: Samples a random configuration from the search space. It samples the goal directly with a probability of `GOAL_BIAS`.
*   `nearest_node(tree, config)`: Finds the node in the tree that is closest to the given configuration `config`.
*   `steer(from_pos, to_pos)`: Calculates a new position by steering from `from_pos` towards `to_pos` with a maximum distance of `DELTA`.
*   `is_collision_free(from_pos, to_pos)`: Checks for collisions along the path segment between `from_pos` and `to_pos` by discretizing the segment and checking for collisions at each intermediate point.
*   `reconstruct_path(goal_node)`: Reconstructs the path from the goal node back to the root by following parent pointers.

### Initialization

*   Creates a `Drone` object at the `start_pos`.
*   Initializes the RRT tree with a root node at the `start_pos`.

### Main Loop

1.  **RRT Algorithm (if path not found):**
    *   Samples a random configuration.
    *   Finds the nearest node in the tree to the sampled configuration.
    *   Steers from the nearest node towards the sampled configuration to create a new position.
    *   Checks for collisions along the path to the new position.
    *   If collision-free, adds a new node at the new position to the tree and visualizes the new edge (blue line).
    *   Checks if the goal has been reached (within `GOAL_REACH_THRESHOLD`).
    *   If the goal is reached, reconstructs the path and visualizes it (red line).

2.  **Drone Movement (if path found):**
    *   Moves the drone along the generated path, one segment at a time using function `move_along_path()`.

3.  **Physics Simulation:** `p.stepSimulation()` advances the PyBullet physics simulation.
4.  **Visualization:** The simulation is visualized in the PyBullet GUI. `time.sleep()` controls the speed.

## Running the Simulation

### Prerequisites

*   Python 3.x
*   PyBullet
*   Gymnasium
*   NumPy

### Installation

```bash
pip install gymnasium pybullet numpy